If you're sharp-eyed, you notice Amplify created configuration in `aws-exports.js`, which contains something like.

```javascript
// WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten.

const awsmobile = {
    "aws_project_region": "us-east-1",
    "aws_appsync_graphqlEndpoint": "https://xxx.appsync-api.us-east-1.amazonaws.com/graphql",
    "aws_appsync_region": "us-east-1",
    "aws_appsync_authenticationType": "API_KEY",
    "aws_appsync_apiKey": "xxx"
};


export default awsmobile;
```

Let Amplify maintain this file just like it says.

## Initialize Amplify

We need to import and initialize Amplify with this. We only need to do it once, so let's put it in `index.tsx`.

!!! note
    This goes in `index.tsx`.

```typescript
import Amplify from '@aws-amplify/core';
import amplify_configuration from './aws-exports';

Amplify.configure(amplify_configuration);
```

## Generate model definitions from GraphQL schema

```shell
amplify codegen models
```

creates a new folder `models` with interface definitions for everything defined in `schema.graphql`.

We lied about `DTOs.ts` being useful. You can delete that file now because we're getting the data classes from our generated code instead.

Now import the `Vehicle` interface from the generated model.

!!! note
    This is in `Vehicles.tsx`.

```typescript
import { Vehicle } from './models';
```

!!! warning
    TBD: Did we add the ID field yet?

We have to create a new Vehicle instance in a slightly different way. This is because the model now has as ID field. DataStore runtime creates that. Generated models have a constructor that does not require it.

```typescript
const vehicle = new Vehicle({ make, model, mileage });
```

Try it. Behaves as before, right?

## Use the DataStore API in `Vehicles.tsx`

The `DataStore` API is an alternative to using the raw GraphQL API, which can get a bit fiddly to get right at first.

!!! note
    We're going to keep the state as-is for now. You'll see that the way we use it is inefficient because we're fetching all vehicles every time we make a change. The basic table provided by React Material does not provide pagination with lazy loading. We'll get to a solution for this in a bit. But it's a bit complicated and might throw us off the scent if we do that now.

    If you're curious, we'll show you how to use Material Table, <https://material-table.com>

Import it.

```typescript
import { DataStore } from '@aws-amplify/datastore';
```

We're going to _subscribe_ to changes and reload all the vehicles every time we get an event. We're not going to use `setVehicles()` in the button handlers themselves. Instead we call the `DataStore` API and let the subscription handler be the only place that calls `setVehicles()` 

Subscription is a great candidate for another React hook, `withEffect()`. Read that as "with side-effect". You can find out more here: <https://reactjs.org/docs/hooks-effect.html>. 

