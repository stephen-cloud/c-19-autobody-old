{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Here is the full documentation for creating the C-19 Autobody sample application in https://github.com/stephen-cloud/c-19-autobody . Why C-19 Autobody? Well, I was laid off from my company as a result of COVID-19. Sales being down. A lot. So between talking to recruiters and having interviews, I learned lots of things I didn't know and put them together. And C-19 because I'm helping a buddy of mine with tech in his autobody shop. And I just saw an article on the C-19 antibody. Here's are the features and technologies we're using to implement them. Feature Technology A type safe(r) programming language TypeScript A User Interface React Material Sign-up, sign-in, forgot password AWS Amplify Authentication A back-end API GraphQL schema definition + AWS Amplify GraphQL API A database AWS Amplify API + AWS DynamoDB Subscribe to data changes; handle off-line edits AWS AppSync The upshot \u00b6 After you follow all the steps, you'll have a React Material web application backed by a GraphQL backend in AWS. The application manages the basics of an Autobody shop ... TDB The application is only a demo: It doesn't actually fix cars.","title":"Home"},{"location":"#the-upshot","text":"After you follow all the steps, you'll have a React Material web application backed by a GraphQL backend in AWS. The application manages the basics of an Autobody shop ... TDB The application is only a demo: It doesn't actually fix cars.","title":"The upshot"},{"location":"add-table-view/","text":"We just got the button hooked up and printed out the state. Clearly JSON is not a good format for mortals. Let's create a table. Luckily it's easy. Import more elements from @material-ui/core . import { Button , Table , TableHead , TableRow , TableCell , TableBody } from '@material-ui/core' ; Replace the return statement with return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /> ); Let's unpack that. We need <> ... </> around all the elements because as there can only be one top-level element. We have two: The <Button> and the <Table> . Note The table definition is the analog of basic HTML tables with a head and a body. The { ... } inside the <TableBody> lets us run display logic, in this case loop over the vehicles and generate table rows. There must be only one statement inside { ... } and that code must return React elements. Try it. Not bad. But there's more. Layout likes to be on a <Grid> \u00b6 Responsive UI frameworks are usually based around the idea of layout in twelve columns. React is one of those frameworks. The layout of the page without a grid is actually OK. If we had lots of elements it might be hard to add all the spacing by hand to get things even. And if we didn't like it there'd be lots of place to change it. We can control all the layout you need with grids. Another thing's irksome. The button's always on a line on its own, even when the page is wide enough to have the button on the left and the table in the remaining space. There's room. Let's do it. Add a <Grid> with some spacing around the <Button> and <Table> elements. import { Grid } from '@material-ui/core' ; < Grid container spacing = { 2 } > < Button onClick = { onClick } > Add vehicle < /Button> < Table > ... < /Table> < /Grid> Refresh. Not much difference. That's because a <Grid container> lays out <Grid item> s and we don't have any yet. Add the two items inside the container. < Grid container spacing = { 2 } > < Grid item > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item > < Table > ... This lays out the button and table items side-by-side. Try resizing the screen. Things move around as the screen size changes. We want to lay out grid items in an actual grid. We saw the default for <Grid item> is to flow items. That's really not very gridy. We can specify breakpoint values for items (any number of xs , sm , md , lg , and xl values) with a column span, which can be 1 (1 column) through 12 (the whole row.) Each breakpoint defines the behavior of responsive design, the way page layout changes to accommodate different screen sizes. Info See https://material-ui.com/customization/breakpoints/ for the details. So with all that, now < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > ... < /Table> < /Grid> < /Grid> will layout both the button and the table full width if the screen size is less than 600px. and side-by-side if the size if 600px or above. Try waggling the bottom-right corner of the browser around to see the button and table move relative to each other. This is responsive design at work with defined columns. Note <Grid container spacing={??}> adds spacing between cells of the grid: It does not affect margins of the grid container itself. You can try different values for the padding and see this work. The upshot \u00b6 We added an array of Vehicles as state, a button to add a new one with some random values for the fields for make , model , and mileage , and a list of them that updates as we add a vehicle. The table's pretty lame: There's no pagination, editing, sorting, or filtering. That's in our future. Here's the whole file, Vehicles.tsx with everything we did. import React from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ; export default Vehicles ; Now we're going to integrate the UI we just made with the backend database.","title":"Add a table"},{"location":"add-table-view/#layout-likes-to-be-on-a-ltgridgt","text":"Responsive UI frameworks are usually based around the idea of layout in twelve columns. React is one of those frameworks. The layout of the page without a grid is actually OK. If we had lots of elements it might be hard to add all the spacing by hand to get things even. And if we didn't like it there'd be lots of place to change it. We can control all the layout you need with grids. Another thing's irksome. The button's always on a line on its own, even when the page is wide enough to have the button on the left and the table in the remaining space. There's room. Let's do it. Add a <Grid> with some spacing around the <Button> and <Table> elements. import { Grid } from '@material-ui/core' ; < Grid container spacing = { 2 } > < Button onClick = { onClick } > Add vehicle < /Button> < Table > ... < /Table> < /Grid> Refresh. Not much difference. That's because a <Grid container> lays out <Grid item> s and we don't have any yet. Add the two items inside the container. < Grid container spacing = { 2 } > < Grid item > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item > < Table > ... This lays out the button and table items side-by-side. Try resizing the screen. Things move around as the screen size changes. We want to lay out grid items in an actual grid. We saw the default for <Grid item> is to flow items. That's really not very gridy. We can specify breakpoint values for items (any number of xs , sm , md , lg , and xl values) with a column span, which can be 1 (1 column) through 12 (the whole row.) Each breakpoint defines the behavior of responsive design, the way page layout changes to accommodate different screen sizes. Info See https://material-ui.com/customization/breakpoints/ for the details. So with all that, now < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > ... < /Table> < /Grid> < /Grid> will layout both the button and the table full width if the screen size is less than 600px. and side-by-side if the size if 600px or above. Try waggling the bottom-right corner of the browser around to see the button and table move relative to each other. This is responsive design at work with defined columns. Note <Grid container spacing={??}> adds spacing between cells of the grid: It does not affect margins of the grid container itself. You can try different values for the padding and see this work.","title":"Layout likes to be on a &amp;lt;Grid&amp;gt;"},{"location":"add-table-view/#the-upshot","text":"We added an array of Vehicles as state, a button to add a new one with some random values for the fields for make , model , and mileage , and a list of them that updates as we add a vehicle. The table's pretty lame: There's no pagination, editing, sorting, or filtering. That's in our future. Here's the whole file, Vehicles.tsx with everything we did. import React from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ; export default Vehicles ; Now we're going to integrate the UI we just made with the backend database.","title":"The upshot"},{"location":"amplify/","text":"AWS Amplify is a pretty great. It lets you add lots of production quality features to your web and mobile apps hat you'd just have to do by hand otherwise. It's a managed service and tool chain for mobile and web apps. Get started with the Amplify Docs . To install Amplify, follow these instructions . In a nutshell, here's what's in the Amplify framework. Feature What it does How we use it in C-19 Autobody API Lets you define arbitrary APIs using REST or GraphQL. API endpoints can be backed by AWS Lambdas. GraphQL endpoint are backed by DynamoDB. We use some of the available GraphQL queries and mutations. Auth Uses AWS Cognito to create a full-featured sign-up, sign-on, forgot my password, and so on. We use all the things. We get a full-featured authentication experience out-of-the-box with very little extra effort. DataStore A cross-device data storage synchronization that uses GraphQL. You can also subscribe to changes in data from other users and devices. This works whether you're online or offline: Synchronization uses optimistic locking. As we're storing data through the DataStore API, the data will be stored in DynamoDB. Other devices (even browser tabs) will subscribe and update in realtime. Interactions Amplify lets you integrate with Amazon Alexa for chat bots and similar Predictions Integrates Amazon Machine Learning. PubSub Amplify provides connectivity to message systems. Push Notifications Uses Amazon Pinpoint for segmentation and campaigns Storage Can upload images and other data to S3 from an application Let's install AWS Amplify in your project \u00b6 Inside your React Material project folder, execute amplify init OK. So this is a lot of stuff all of a sudden. Don't panic. Just mostly accept the defaults and add c-19-autobody as the projects name and dev as the environment. Here's what it looks like in my terminal Warning TBD: just create a table of the questions/responses \u00bb amplify init Note: It is recommended to run this command from the root of your app directory ? Enter a name for the project c-19-autobody ? Enter a name for the environment dev ? Choose your default editor: Visual Studio Code ? Choose the type of app that you 're building javascript Please tell us about your project ? What javascript framework are you using react ? Source Directory Path: src ? Distribution Directory Path: build ? Build Command: npm run-script build ? Start Command: npm run-script start Using default provider awscloudformation For more information on AWS Profiles, see: https://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html ? Do you want to use an AWS profile? Yes ? Please choose the profile you want to use default Adding backend environment dev to AWS Amplify Console app: d15ddnbwqjrf7u \u2827 Initializing project in the cloud... ... \u2714 Successfully created initial AWS cloud resources for deployments. \u2714 Initialized provider successfully. Initialized your environment successfully. Your project has been successfully initialized and connected to the cloud! Some next steps: \"amplify status\" will show you what you' ve added already and if it ' s locally configured or deployed \"amplify add <category>\" will allow you to add features like user login or a backend API \"amplify push\" will build all your local backend resources and provision it in the cloud \u201camplify console\u201d to open the Amplify Console and view your project status \"amplify publish\" will build all your local backend and frontend resources ( if you have hosting category added ) and provision it in the cloud Pro tip: Try \"amplify add api\" to create a backend API and then \"amplify publish\" to deploy everything \u00bb Run amplify status There's nothing much to do just yet. Let's check everything still works with yarn start . It still works with any luck. (You can run this command after every step to make sure you're following along.) Add an Amplify managed API \u00b6 amplify add api You'll be asked a few more things. Warning TBD: so what are they? When you're asked \"Do you want to edit the schema now?\" say yes and replace the contents with type Vehicle @model { id: ID! make: String! model: String! mileage: Int } Deploy the back-end resources to the cloud \u00b6 Note The amplify add ... commands generally capture and save configuration. Some other commands set things up from this configuration. amplify push generates code from the GraphQL schema, for example. amplify push Enter Y for all the prompts. All this definitely doesn't do anything interesting yet: We're just setting up all the moving parts. Verify the UI still works, yarn start . The upshot \u00b6 TBD: what we did","title":"Add AWS Amplify"},{"location":"amplify/#lets-install-aws-amplify-in-your-project","text":"Inside your React Material project folder, execute amplify init OK. So this is a lot of stuff all of a sudden. Don't panic. Just mostly accept the defaults and add c-19-autobody as the projects name and dev as the environment. Here's what it looks like in my terminal Warning TBD: just create a table of the questions/responses \u00bb amplify init Note: It is recommended to run this command from the root of your app directory ? Enter a name for the project c-19-autobody ? Enter a name for the environment dev ? Choose your default editor: Visual Studio Code ? Choose the type of app that you 're building javascript Please tell us about your project ? What javascript framework are you using react ? Source Directory Path: src ? Distribution Directory Path: build ? Build Command: npm run-script build ? Start Command: npm run-script start Using default provider awscloudformation For more information on AWS Profiles, see: https://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html ? Do you want to use an AWS profile? Yes ? Please choose the profile you want to use default Adding backend environment dev to AWS Amplify Console app: d15ddnbwqjrf7u \u2827 Initializing project in the cloud... ... \u2714 Successfully created initial AWS cloud resources for deployments. \u2714 Initialized provider successfully. Initialized your environment successfully. Your project has been successfully initialized and connected to the cloud! Some next steps: \"amplify status\" will show you what you' ve added already and if it ' s locally configured or deployed \"amplify add <category>\" will allow you to add features like user login or a backend API \"amplify push\" will build all your local backend resources and provision it in the cloud \u201camplify console\u201d to open the Amplify Console and view your project status \"amplify publish\" will build all your local backend and frontend resources ( if you have hosting category added ) and provision it in the cloud Pro tip: Try \"amplify add api\" to create a backend API and then \"amplify publish\" to deploy everything \u00bb Run amplify status There's nothing much to do just yet. Let's check everything still works with yarn start . It still works with any luck. (You can run this command after every step to make sure you're following along.)","title":"Let's install AWS Amplify in your project"},{"location":"amplify/#add-an-amplify-managed-api","text":"amplify add api You'll be asked a few more things. Warning TBD: so what are they? When you're asked \"Do you want to edit the schema now?\" say yes and replace the contents with type Vehicle @model { id: ID! make: String! model: String! mileage: Int }","title":"Add an Amplify managed API"},{"location":"amplify/#deploy-the-back-end-resources-to-the-cloud","text":"Note The amplify add ... commands generally capture and save configuration. Some other commands set things up from this configuration. amplify push generates code from the GraphQL schema, for example. amplify push Enter Y for all the prompts. All this definitely doesn't do anything interesting yet: We're just setting up all the moving parts. Verify the UI still works, yarn start .","title":"Deploy the back-end resources to the cloud"},{"location":"amplify/#the-upshot","text":"TBD: what we did","title":"The upshot"},{"location":"awesome-table/","text":"Error Wow is the code and this page ever a mess. As we already saw, the table that displays all the vehicles is lame. It does not paginate and it only works on all the vehicles at once. It does not let you create, update, or update the data within the table. In addition, we had to create the table from scratch using the basic elements of Material UI. Let's fix that. Or rather, let someone else fix it for us. Enter the magnificent Material Table, https://material-table.com . We're just about tp make some big changes tp Vehicle.tsx with quite a few steps. As always, if you want to skip the steps and see the end result check \"The upshot\" section. Start simple \u00b6 Let's hook up Material Table to the existing data. Add the dependency yarn add material-table Import the table. import MaterialTable from 'material-table' There's a ton of options for each column so we use the type Column to leverage editor completion. Always nice. numeric aligns right. Material Table requires a mutable id on each row. AWS Amplify provides and id , but it's readonly . So things won't work if you just pass a Vehicle around for rows. A quick fix is map each Vehicle to an untyped object. I found this out and figured out the fix so you don't have to. The function rowMapper() does this. function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } And define some column metadata. const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" }, ]; Now we have everything we need to replace our old table with the nice one. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { rowMapper ()} columns = { columns } /> < /Grid> < /Grid> ); Try it. Ugh. Looks like we need some icons. Follow the instructions in https://material-table.com/#/docs/install . Yay. This table's already looking amazing. Search works for string and numeric fields. But of course we're not stopping here \u00b6 We're not, because this is a tutorial on Material Table among several other things. There's still lots to do before we're awesome. Try pressing the \"ADD VEHICLE\" button. See the total increase? Cool. Press it 1,000 more times. It slows down. A lot. Retrieving all the vehicles every time clearly doesn't work. Not so cool. Let's paginate. But first\u2014in a bold move\u2014remove the state and fetchAll() . Comment it out in subscriber() . We're going need something here, and this will remind us. function Vehicles() now starts function Vehicles() { useEffect (() => { function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); // fetchAll(); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { ... The data property in <MaterialTable ... /> can also take a function. Fields in the function argument, the query, allow us to retrieve just the right single page of vehicles. We'll take query.page and query.pageSize and call DataStore.query() to get just the right page. Oh, and data needs a Promise now. Oh, and DataStore.query() needs a predicate now, even the always-true predicate. data = { query => new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , Predicates . ALL , thisPage ) . then ( vehicles => resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : query.pageSize })) . catch ( reject ); }) } In-line is OK. But we can do better. Here's the above as a function with all the right types. function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } And now our table element looks like < MaterialTable data = { data } columns = { columns } /> We broke some things \u00b6 Only first page is displayed. And we don't refresh when we add a vehicle. (You might have noticed we set totalCount to a large number to get something going until we solve this.) There are a couple of reasons for this. For pagination to work correctly, Material Table needs to know the total number of rows. That used to be easy because we had all the rows. But now we only have a page at a time. Note It turns out that this is much harder than you'd think. It's because we're using GraphQL backed by DynamoDB. DynamoDB does not work like SQL where you can SELECT COUNT(*) ... or something. There's no way to get the total number without scanning a whole table, which is prohibitively expensive for large tables. We're going to solve this another way. But fair warning, this is going to feel like we don't know what we're doing. Search is broken now too \u00b6 It looks like there's a bad interaction between what we're now doing in Material Table and how we're using Amplify DataStore to fetch a page. Let's fix it. DataStore.query(...) takes a predicate, specifically a function that takes a ModelPredicate<Vehicle> and returns one too. Our task is to add some search criterial. We can take query.search and create criteria. Start with make . DataStore . query ( Vehicle , c => c . make ( \"contains\" , query . search ), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }) }) . catch ( reject ); We can type a search term and get matching vehicle makes. Nice. Compound criteria are constructed like this c => c . make ( \"contains\" , query . search ). model ( \"contains\" , query . search ), but when we try it we discover that is an and criterion. We need or . This is the right incantation for that. c => c . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search )), Adding search on mileage is easy. We just have to think of a reasonable semantics. \"Is greater than or equal\" is probably better than \"contains these digits.\" Now we have DataStore . query ( Vehicle , c => c . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }) }) . catch ( reject ); Search is fixed. We see there's a default title that's not very useful. Let's leave all the polish like this until after everything's working. Triggering refresh \u00b6 We can add vehicles as before, but they're not showing up in the table. We need to plug in the subscription to the table to refresh it. It's pretty easy if you know how. We need to add a reference to the table we can use to trigger a refresh. import React , { useEffect , createRef } from 'react' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps } from 'material-table' const tableRef = createRef < MaterialTableProps < Vehicle >> (); Now bind it to the table like this. < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } /> Now all we have to do to trigger a refresh on the table when we get an event from the subscription. It's a bit finicky. Just skip to The new useEffect if you want. Otherwise here are the details. We going to trip the table's onQueryChange() hook. That function requires some arguments, which we mostly relay from the current table state. There are a couple of things we didn't figure out how to get from the table state like the current orderBy . Irksome, but not a deal-breaker. Ever wonder what that empty [] was in the userEffect() hook declaration? Well it's for passing dependencies. tableRef is a dependency. The new useEffect \u00b6 useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); }, [ tableRef ]); Try it. Much better. If you want to delete all existing vehicles and start over, you can add a <Button> and call DataStore . Like this < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> function onDeleteAll ( event : React.MouseEvent ) { DataStore . delete ( Vehicle , Predicates . ALL ) . then ( console . log ) . catch ( console . error ) event . preventDefault (); } Well that's a lot of redrawing of the table. We'll see if we can fix that later when we polish. Note If you want to skip the details of making rows editable, skip to The complete editable definition Manipulating items from the table itself \u00b6 The \"ADD VEHICLE\" button has a bunch of issues. Let's move that functionality to the table. Removing buttons simplifies the layout. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); Material Table provides hooks for CRUD operations right in the table. The hooks are defined as editable ?: { isEditable ?: ( rowData : RowData ) => boolean ; isDeletable ?: ( rowData : RowData ) => boolean ; onRowAdd ?: ( newData : RowData ) => Promise < any > ; onRowUpdate ?: ( newData : RowData , oldData? : RowData ) => Promise < any > ; onRowDelete ?: ( oldData : RowData ) => Promise < any > ; } Let's add them one-by-one. All hooks are optional. const editable = { }; < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> Test it. Nothing does nothing successfully. Before we can edit a row that has optional fields\u2014our mileage field\u2014we need to define a value returned when omitted. This is easy: Just add it to the Column . const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; Add a function to edit a row. We get save and cancel buttons for free. const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , } Let's unpack this. onRowAdd returns a Promise . That's easy: we just have to call resolve or reject like we already know. We setTimeout() to 1000ms and clearTimeout() only if the save succeeds. Now enable deleting a row \u00b6 The function for onRowDelete looks very similar to that for onRowAdd . const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , } Try it. Yay, a rubbish bin. Still noticing quite a bit of table flash. Updating a row \u00b6 const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) The last one's a bit sneaky. It's chaining Promise s by returning a Promise from the first .then . Just in case you didn't know a way to do this. Note Oh wow. We just noticed we got column sorting for free somehow. Some spit and polish \u00b6 Material Table takes options. Lots of options. Let's us a couple of quick ones here. Remove the total number of rows for the display in pagination. const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } Remove the title and change the way we display pages. const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } So now our Material Table looks like < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> The upshot \u00b6 We integrated Amplify DataStore and Material Table. I think it was well worth it. It would have taken ages to do this from scratch. There are some wrinkles, but not enough we can't press on. Our final Vehicles.tsx is this import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"Integrate Amplify"},{"location":"awesome-table/#start-simple","text":"Let's hook up Material Table to the existing data. Add the dependency yarn add material-table Import the table. import MaterialTable from 'material-table' There's a ton of options for each column so we use the type Column to leverage editor completion. Always nice. numeric aligns right. Material Table requires a mutable id on each row. AWS Amplify provides and id , but it's readonly . So things won't work if you just pass a Vehicle around for rows. A quick fix is map each Vehicle to an untyped object. I found this out and figured out the fix so you don't have to. The function rowMapper() does this. function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } And define some column metadata. const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" }, ]; Now we have everything we need to replace our old table with the nice one. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { rowMapper ()} columns = { columns } /> < /Grid> < /Grid> ); Try it. Ugh. Looks like we need some icons. Follow the instructions in https://material-table.com/#/docs/install . Yay. This table's already looking amazing. Search works for string and numeric fields.","title":"Start simple"},{"location":"awesome-table/#but-of-course-were-not-stopping-here","text":"We're not, because this is a tutorial on Material Table among several other things. There's still lots to do before we're awesome. Try pressing the \"ADD VEHICLE\" button. See the total increase? Cool. Press it 1,000 more times. It slows down. A lot. Retrieving all the vehicles every time clearly doesn't work. Not so cool. Let's paginate. But first\u2014in a bold move\u2014remove the state and fetchAll() . Comment it out in subscriber() . We're going need something here, and this will remind us. function Vehicles() now starts function Vehicles() { useEffect (() => { function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); // fetchAll(); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { ... The data property in <MaterialTable ... /> can also take a function. Fields in the function argument, the query, allow us to retrieve just the right single page of vehicles. We'll take query.page and query.pageSize and call DataStore.query() to get just the right page. Oh, and data needs a Promise now. Oh, and DataStore.query() needs a predicate now, even the always-true predicate. data = { query => new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , Predicates . ALL , thisPage ) . then ( vehicles => resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : query.pageSize })) . catch ( reject ); }) } In-line is OK. But we can do better. Here's the above as a function with all the right types. function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } And now our table element looks like < MaterialTable data = { data } columns = { columns } />","title":"But of course we're not stopping here"},{"location":"awesome-table/#we-broke-some-things","text":"Only first page is displayed. And we don't refresh when we add a vehicle. (You might have noticed we set totalCount to a large number to get something going until we solve this.) There are a couple of reasons for this. For pagination to work correctly, Material Table needs to know the total number of rows. That used to be easy because we had all the rows. But now we only have a page at a time. Note It turns out that this is much harder than you'd think. It's because we're using GraphQL backed by DynamoDB. DynamoDB does not work like SQL where you can SELECT COUNT(*) ... or something. There's no way to get the total number without scanning a whole table, which is prohibitively expensive for large tables. We're going to solve this another way. But fair warning, this is going to feel like we don't know what we're doing.","title":"We broke some things"},{"location":"awesome-table/#search-is-broken-now-too","text":"It looks like there's a bad interaction between what we're now doing in Material Table and how we're using Amplify DataStore to fetch a page. Let's fix it. DataStore.query(...) takes a predicate, specifically a function that takes a ModelPredicate<Vehicle> and returns one too. Our task is to add some search criterial. We can take query.search and create criteria. Start with make . DataStore . query ( Vehicle , c => c . make ( \"contains\" , query . search ), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }) }) . catch ( reject ); We can type a search term and get matching vehicle makes. Nice. Compound criteria are constructed like this c => c . make ( \"contains\" , query . search ). model ( \"contains\" , query . search ), but when we try it we discover that is an and criterion. We need or . This is the right incantation for that. c => c . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search )), Adding search on mileage is easy. We just have to think of a reasonable semantics. \"Is greater than or equal\" is probably better than \"contains these digits.\" Now we have DataStore . query ( Vehicle , c => c . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }) }) . catch ( reject ); Search is fixed. We see there's a default title that's not very useful. Let's leave all the polish like this until after everything's working.","title":"Search is broken now too"},{"location":"awesome-table/#triggering-refresh","text":"We can add vehicles as before, but they're not showing up in the table. We need to plug in the subscription to the table to refresh it. It's pretty easy if you know how. We need to add a reference to the table we can use to trigger a refresh. import React , { useEffect , createRef } from 'react' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps } from 'material-table' const tableRef = createRef < MaterialTableProps < Vehicle >> (); Now bind it to the table like this. < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } /> Now all we have to do to trigger a refresh on the table when we get an event from the subscription. It's a bit finicky. Just skip to The new useEffect if you want. Otherwise here are the details. We going to trip the table's onQueryChange() hook. That function requires some arguments, which we mostly relay from the current table state. There are a couple of things we didn't figure out how to get from the table state like the current orderBy . Irksome, but not a deal-breaker. Ever wonder what that empty [] was in the userEffect() hook declaration? Well it's for passing dependencies. tableRef is a dependency.","title":"Triggering refresh"},{"location":"awesome-table/#the-new-useeffect","text":"useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); }, [ tableRef ]); Try it. Much better. If you want to delete all existing vehicles and start over, you can add a <Button> and call DataStore . Like this < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> function onDeleteAll ( event : React.MouseEvent ) { DataStore . delete ( Vehicle , Predicates . ALL ) . then ( console . log ) . catch ( console . error ) event . preventDefault (); } Well that's a lot of redrawing of the table. We'll see if we can fix that later when we polish. Note If you want to skip the details of making rows editable, skip to The complete editable definition","title":"The new useEffect"},{"location":"awesome-table/#manipulating-items-from-the-table-itself","text":"The \"ADD VEHICLE\" button has a bunch of issues. Let's move that functionality to the table. Removing buttons simplifies the layout. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); Material Table provides hooks for CRUD operations right in the table. The hooks are defined as editable ?: { isEditable ?: ( rowData : RowData ) => boolean ; isDeletable ?: ( rowData : RowData ) => boolean ; onRowAdd ?: ( newData : RowData ) => Promise < any > ; onRowUpdate ?: ( newData : RowData , oldData? : RowData ) => Promise < any > ; onRowDelete ?: ( oldData : RowData ) => Promise < any > ; } Let's add them one-by-one. All hooks are optional. const editable = { }; < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> Test it. Nothing does nothing successfully. Before we can edit a row that has optional fields\u2014our mileage field\u2014we need to define a value returned when omitted. This is easy: Just add it to the Column . const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; Add a function to edit a row. We get save and cancel buttons for free. const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , } Let's unpack this. onRowAdd returns a Promise . That's easy: we just have to call resolve or reject like we already know. We setTimeout() to 1000ms and clearTimeout() only if the save succeeds.","title":"Manipulating items from the table itself"},{"location":"awesome-table/#now-enable-deleting-a-row","text":"The function for onRowDelete looks very similar to that for onRowAdd . const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , } Try it. Yay, a rubbish bin. Still noticing quite a bit of table flash.","title":"Now enable deleting a row"},{"location":"awesome-table/#updating-a-row","text":"const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) The last one's a bit sneaky. It's chaining Promise s by returning a Promise from the first .then . Just in case you didn't know a way to do this. Note Oh wow. We just noticed we got column sorting for free somehow.","title":"Updating a row"},{"location":"awesome-table/#some-spit-and-polish","text":"Material Table takes options. Lots of options. Let's us a couple of quick ones here. Remove the total number of rows for the display in pagination. const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } Remove the title and change the way we display pages. const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } So now our Material Table looks like < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } />","title":"Some spit and polish"},{"location":"awesome-table/#the-upshot","text":"We integrated Amplify DataStore and Material Table. I think it was well worth it. It would have taken ages to do this from scratch. There are some wrinkles, but not enough we can't press on. Our final Vehicles.tsx is this import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"The upshot"},{"location":"connecttobackend/","text":"Error Where should we put this? What are the responses? amplify update api amplify push Note We're going to keep the state as-is for now. You'll see that the way we use it is inefficient because we're fetching all vehicles every time we make a change. The basic table provided by React Material does not provide pagination with lazy loading. We'll get to a solution for this in a bit. But it's a bit complicated and might throw us off the scent if we do that now. If you're curious, we're going to show you how to use Material Table, https://material-table.com for lots of table goodness. If you're sharp-eyed, you notice Amplify created configuration in aws-exports.js , which contains something like. // WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten. const awsmobile = { \"aws_project_region\" : \"us-east-1\" , \"aws_appsync_graphqlEndpoint\" : \"https://xxx.appsync-api.us-east-1.amazonaws.com/graphql\" , \"aws_appsync_region\" : \"us-east-1\" , \"aws_appsync_authenticationType\" : \"API_KEY\" , \"aws_appsync_apiKey\" : \"xxx\" }; export default awsmobile ; Let Amplify maintain this file just like it says. Initialize Amplify \u00b6 We need to import and initialize Amplify with the configuration in awsmobile . We only need to do it once, so let's put it in index.tsx . Note This goes in index.tsx . import Amplify from '@aws-amplify/core' ; import amplify_configuration from './aws-exports' ; Amplify . configure ( amplify_configuration ); Use the DataStore API in Vehicles.tsx \u00b6 The DataStore API is an alternative to using the raw GraphQL API, which can get a bit fiddly to get right at first. Note This goes in Vehicles.tsx . Using DataStore \u00b6 Import it. import { DataStore } from '@aws-amplify/datastore' ; DataStore functions return Promise s. So we have to handle that in addVehicle() where we save a vehicle, now using DataStore.save() . function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } That's also true for DataStore.query() , the way we're going to fetch data now. Note The default query is all objects. We can supply predicates and pagination details in the query. We'll get to that when we use https://material-table.com/#/ , which lazy loads as it paginates. We use the setVehicles(...) React hook as before. But this time with the results of the DataStore query. Here's that function. function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; Handle subscription events \u00b6 We're going to subscribe to changes in the back-end data and reload all the vehicles every time we get an event. This is AWS AppSync at work. See https://docs.aws.amazon.com/appsync/index.html . This function is handy for tracking events as we get them. import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; ... function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } Observe changes and subscribe to them \u00b6 Now that we have a functions fetchAll() and subscriber() , let's put them together in a withEffect() . Read that as \"with side-effect\". You can find out more here: https://reactjs.org/docs/hooks-effect.html . import React , { useEffect } from 'react' ; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); Now whenever AppSync sends us an update we read the data from DynamoDB and display it. So now we have What How <Button> click handler onClick() on <Button> definition Adding a (random) vehicle addVehicle() in onClick() , which calls the DataStore to save the new vehicle. A subscription event handler subscriber() A subscriber to changes in the Vehicle database In useEffect() Note I guarantee this all seems totally useless and unnecessary at the moment. Just wait. Prepare to be astounded. Let's try it anyway. ( yarn start as usual.) Now for the astonishing bit \u00b6 Open up another browser http://localhost:3000 and watch what happens when you dd a vehicle. You just wrote Google docs for cars. The upshot \u00b6 We configured Amplify. We created an Amplify DataSource observer and subscribed to events from it. We learned just a little about useEffect() and glued that all together. We were a bit astonished at what that allowed us to do if we're being honest. The complete Vehicles.tsx is import React , { useEffect } from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } function onClick ( event : React.MouseEvent ) { addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ;","title":"Connect to the back-end"},{"location":"connecttobackend/#initialize-amplify","text":"We need to import and initialize Amplify with the configuration in awsmobile . We only need to do it once, so let's put it in index.tsx . Note This goes in index.tsx . import Amplify from '@aws-amplify/core' ; import amplify_configuration from './aws-exports' ; Amplify . configure ( amplify_configuration );","title":"Initialize Amplify"},{"location":"connecttobackend/#use-the-datastore-api-in-vehiclestsx","text":"The DataStore API is an alternative to using the raw GraphQL API, which can get a bit fiddly to get right at first. Note This goes in Vehicles.tsx .","title":"Use the DataStore API in Vehicles.tsx"},{"location":"connecttobackend/#using-datastore","text":"Import it. import { DataStore } from '@aws-amplify/datastore' ; DataStore functions return Promise s. So we have to handle that in addVehicle() where we save a vehicle, now using DataStore.save() . function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } That's also true for DataStore.query() , the way we're going to fetch data now. Note The default query is all objects. We can supply predicates and pagination details in the query. We'll get to that when we use https://material-table.com/#/ , which lazy loads as it paginates. We use the setVehicles(...) React hook as before. But this time with the results of the DataStore query. Here's that function. function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); };","title":"Using DataStore"},{"location":"connecttobackend/#handle-subscription-events","text":"We're going to subscribe to changes in the back-end data and reload all the vehicles every time we get an event. This is AWS AppSync at work. See https://docs.aws.amazon.com/appsync/index.html . This function is handy for tracking events as we get them. import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; ... function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); }","title":"Handle subscription events"},{"location":"connecttobackend/#observe-changes-and-subscribe-to-them","text":"Now that we have a functions fetchAll() and subscriber() , let's put them together in a withEffect() . Read that as \"with side-effect\". You can find out more here: https://reactjs.org/docs/hooks-effect.html . import React , { useEffect } from 'react' ; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); Now whenever AppSync sends us an update we read the data from DynamoDB and display it. So now we have What How <Button> click handler onClick() on <Button> definition Adding a (random) vehicle addVehicle() in onClick() , which calls the DataStore to save the new vehicle. A subscription event handler subscriber() A subscriber to changes in the Vehicle database In useEffect() Note I guarantee this all seems totally useless and unnecessary at the moment. Just wait. Prepare to be astounded. Let's try it anyway. ( yarn start as usual.)","title":"Observe changes and subscribe to them"},{"location":"connecttobackend/#now-for-the-astonishing-bit","text":"Open up another browser http://localhost:3000 and watch what happens when you dd a vehicle. You just wrote Google docs for cars.","title":"Now for the astonishing bit"},{"location":"connecttobackend/#the-upshot","text":"We configured Amplify. We created an Amplify DataSource observer and subscribed to events from it. We learned just a little about useEffect() and glued that all together. We were a bit astonished at what that allowed us to do if we're being honest. The complete Vehicles.tsx is import React , { useEffect } from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } function onClick ( event : React.MouseEvent ) { addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ;","title":"The upshot"},{"location":"createproject/","text":"yarn create react-app my-app --template typescript yarn start The upshot \u00b6 ... TBD","title":"Create the project"},{"location":"createproject/#the-upshot","text":"... TBD","title":"The upshot"},{"location":"license/","text":"MIT License Copyright \u00a9 2020 Stephen Harrison Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"material/","text":"Get React Material UI \u00b6 yarn add @material-ui/core A trivial page with a toolbar \u00b6 Replace App.tsx with this import React from 'react'; import { AppBar, Toolbar, Typography } from '@material-ui/core'; function App() { return ( <AppBar color=\"inherit\" position=\"static\"> <Toolbar> <Typography variant=\"h4\" >Welcome to C-19 Autobody</Typography> </Toolbar> </AppBar> ); } export default App; Do you like dark theme? \u00b6 If you like your Material theme dark, change your index.tsx to import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import { createMuiTheme, ThemeProvider, CssBaseline } from '@material-ui/core'; const theme = createMuiTheme({ palette: { type: 'dark', }, }); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <CssBaseline /> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById('root') ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister(); The upshot \u00b6 ... TBD","title":"Add React Material"},{"location":"material/#get-react-material-ui","text":"yarn add @material-ui/core","title":"Get React Material UI"},{"location":"material/#a-trivial-page-with-a-toolbar","text":"Replace App.tsx with this import React from 'react'; import { AppBar, Toolbar, Typography } from '@material-ui/core'; function App() { return ( <AppBar color=\"inherit\" position=\"static\"> <Toolbar> <Typography variant=\"h4\" >Welcome to C-19 Autobody</Typography> </Toolbar> </AppBar> ); } export default App;","title":"A trivial page with a toolbar"},{"location":"material/#do-you-like-dark-theme","text":"If you like your Material theme dark, change your index.tsx to import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import { createMuiTheme, ThemeProvider, CssBaseline } from '@material-ui/core'; const theme = createMuiTheme({ palette: { type: 'dark', }, }); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <CssBaseline /> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById('root') ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister();","title":"Do you like dark theme?"},{"location":"material/#the-upshot","text":"... TBD","title":"The upshot"},{"location":"navigation/","text":"Note If you get turned around with the sequence of updates we're going to make with files, or if you'd rather the TL;DR, click \"The upshot\" on the right to see what's what. Well, first we need to be able to get to pages for all the things you'll be dealing with in an autobody shop: vehicles , owners , services , parts , and work orders . Let's set up a row of buttons for that. They won't be plugged in yet. We'll get to that shortly. Replace App.tsx with import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Button > Home < /Button> < Button > Vehicles < /Button> < Button > Owners < /Button> < Button > Services < /Button> < Button > Parts < /Button> < Button > Work Orders < /Button> < /div> < /AppBar> < /> ); } export default App ; Try it. Getting better. We can argue about spacing later. The out-of-the-box spacing is at least not completely wrong. Create stubs for all the components \u00b6 For the Home component, simply add the file Home.tsx in the src directory with the content below. We're going to add routing to these in bit. import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( < Typography variant = \"h3\" > Home < /Typography> ); } export default Home ; Do the same for Vehicles, Owners, Services, Parts, and WorkOrders. For Work Orders, call the file WorkOrders.tsx . Note Remember there are 3 places you need to change the name of each component. Add routes to those stubs \u00b6 First add the react-router-dom dependency and TypeScript definitions. yarn add react-router-dom @types/react-router-dom Now wrap the App component in a <BrowserRouter> ... </BrowserRouter> . The easiest place to do this is in index.tsx . Note Make these changes in index.tsx Add the import import { BrowserRouter } from \"react-router-dom\" ; And then wrap the existing <App /> like this ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); Add some actual routing \u00b6 It's actually pretty easy now we have the stub components and the <BrowserRouter> wrapper. Note Make these changes in App.tsx Replace the <Button> s in the <AppBar> with <Link> s and the bindings from routes to the components. We'll need a few more imports. See the complete App.tsx in the upshot below. Try it with yarn start . Warning We know. It looks dreadful right now. We're going to clean it up in a bit. The upshot \u00b6 After all our changes, here's where we ended up. index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); App.tsx is import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; import { Link , Route , Switch } from 'react-router-dom' ; import Home from './Home' ; import Vehicles from './Vehicles' ; import Owners from './Owners' ; import Services from './Services' ; import Parts from './Parts' ; import WorkOrders from './WorkOrders' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> < /AppBar> < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Owners } /> < Route path = \"/services\" component = { Services } /> < Route path = \"/parts\" component = { Parts } /> < Route path = \"/workorders\" component = { WorkOrders } /> < /Switch> < /main> < /> ); } export default App ; We defined components for Home , Vehicles , Owners , Services , Parts , and Work Orders in files in src called Home.tsx and so on, with the pattern import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( <> < Typography variant = \"h3\" > Home < /Typography> < /> ); } export default Home ; As we pointed out above, it's not going to win any design awards. Keep going.","title":"Add navigation"},{"location":"navigation/#create-stubs-for-all-the-components","text":"For the Home component, simply add the file Home.tsx in the src directory with the content below. We're going to add routing to these in bit. import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( < Typography variant = \"h3\" > Home < /Typography> ); } export default Home ; Do the same for Vehicles, Owners, Services, Parts, and WorkOrders. For Work Orders, call the file WorkOrders.tsx . Note Remember there are 3 places you need to change the name of each component.","title":"Create stubs for all the components"},{"location":"navigation/#add-routes-to-those-stubs","text":"First add the react-router-dom dependency and TypeScript definitions. yarn add react-router-dom @types/react-router-dom Now wrap the App component in a <BrowserRouter> ... </BrowserRouter> . The easiest place to do this is in index.tsx . Note Make these changes in index.tsx Add the import import { BrowserRouter } from \"react-router-dom\" ; And then wrap the existing <App /> like this ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) );","title":"Add routes to those stubs"},{"location":"navigation/#add-some-actual-routing","text":"It's actually pretty easy now we have the stub components and the <BrowserRouter> wrapper. Note Make these changes in App.tsx Replace the <Button> s in the <AppBar> with <Link> s and the bindings from routes to the components. We'll need a few more imports. See the complete App.tsx in the upshot below. Try it with yarn start . Warning We know. It looks dreadful right now. We're going to clean it up in a bit.","title":"Add some actual routing"},{"location":"navigation/#the-upshot","text":"After all our changes, here's where we ended up. index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); App.tsx is import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; import { Link , Route , Switch } from 'react-router-dom' ; import Home from './Home' ; import Vehicles from './Vehicles' ; import Owners from './Owners' ; import Services from './Services' ; import Parts from './Parts' ; import WorkOrders from './WorkOrders' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> < /AppBar> < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Owners } /> < Route path = \"/services\" component = { Services } /> < Route path = \"/parts\" component = { Parts } /> < Route path = \"/workorders\" component = { WorkOrders } /> < /Switch> < /main> < /> ); } export default App ; We defined components for Home , Vehicles , Owners , Services , Parts , and Work Orders in files in src called Home.tsx and so on, with the pattern import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( <> < Typography variant = \"h3\" > Home < /Typography> < /> ); } export default Home ; As we pointed out above, it's not going to win any design awards. Keep going.","title":"The upshot"},{"location":"prepare-ui/","text":"We're going to add code to one of the pages\u2014vehicles\u2014to add a vehicle and list them out. We just generate random values for fields for now. And it won't be hooked up to the back end. But this will let us see how to update state and display the complete list. First add Amplify dependencies \u00b6 yarn add aws-amplify @aws-amplify/ui-react We're not going to use these right off the bat, but let's do it while we're thinking of it. A little layout \u00b6 Lets solve the ugly indentation of the \"Vehicles\" header. Actually, let's solve the problem for all pages at the same time. This is easy: Just add a simple style to App.tsx . Define a style before the function definition like this. Note This goes in App.tsx . import { makeStyles } from '@material-ui/core' ; const useStyles = makeStyles (( theme ) => ({ content : { // top, right, bottom, left margin : theme.spacing ( 2 , 2 , 0 , 2 ) } })); Remember the theme argument lets us use spacing from the theme itself. We could use hard-coded pixel sizes, but we'd have to update all those manually every time the theme changes. That would be not only annoying, but in addition your pull request would be rejected and no one on your team will want to go to lunch with you today. makeStyles() returns a function. We get the classNames from the result of calling this function. And we use it referencing the class name. function App() { const classes = useStyles (); return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> ... < /div> < /AppBar> < div className = { classes . content } > < main > < Switch > < Route path = \"/\" component = { Home } exact /> ... < /Switch> < /main> < /div> < /> ); } It's looking quite a bit better. Now add some state for the list of vehicles \u00b6 Note All this goes in Vehicles.tsx Import the new Vehicle class import { Vehicle } from './models' ; We maintain state using React hooks. See https://reactjs.org/docs/hooks-overview.html . Hooks are so cool. const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]) We'll be using random placeholders for fields: UUIDs are just the ticket. yarn add uuidv4 @types/uuid And import it import { uuid } from 'uuidv4' ; Code to update the list of vehicles \u00b6 A new function, addVehicle() adds a vehicle to the vehicles state. This goes function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } Note The Vehicle class contains metadata that Amplify runtime uses for persistence. This is out-of-bounds for us to update directly. However all persistent classes derived from schema.graphql \u2014including our Vehicle class\u2014includes a constructor with just our fields except id , which is considered part of the metadata. Add a <Button onClick{...}> handler. This also needs to be inside the main function. function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } The event.preventDefault(); is necessary because React decorates native DOM events and we don't want the browser to refresh or reload the window with the underlying event. Add a <Button> and wire up the onclick() handler, and replace the existing <Typography> element with some JSON. import { Typography , Button } from '@material-ui/core' ; return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); Try it out. Nice. Now there's a button \"ADD VEHICLE\" and some JSON for all the vehicles we're adding. The upshot \u00b6 We make a very primitive component that updates and displays state. Vehicles.tsx is now import React from 'react' ; import { Typography , Button } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); } export default Vehicles ;","title":"Prepare the UI"},{"location":"prepare-ui/#first-add-amplify-dependencies","text":"yarn add aws-amplify @aws-amplify/ui-react We're not going to use these right off the bat, but let's do it while we're thinking of it.","title":"First add Amplify dependencies"},{"location":"prepare-ui/#a-little-layout","text":"Lets solve the ugly indentation of the \"Vehicles\" header. Actually, let's solve the problem for all pages at the same time. This is easy: Just add a simple style to App.tsx . Define a style before the function definition like this. Note This goes in App.tsx . import { makeStyles } from '@material-ui/core' ; const useStyles = makeStyles (( theme ) => ({ content : { // top, right, bottom, left margin : theme.spacing ( 2 , 2 , 0 , 2 ) } })); Remember the theme argument lets us use spacing from the theme itself. We could use hard-coded pixel sizes, but we'd have to update all those manually every time the theme changes. That would be not only annoying, but in addition your pull request would be rejected and no one on your team will want to go to lunch with you today. makeStyles() returns a function. We get the classNames from the result of calling this function. And we use it referencing the class name. function App() { const classes = useStyles (); return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> ... < /div> < /AppBar> < div className = { classes . content } > < main > < Switch > < Route path = \"/\" component = { Home } exact /> ... < /Switch> < /main> < /div> < /> ); } It's looking quite a bit better.","title":"A little layout"},{"location":"prepare-ui/#now-add-some-state-for-the-list-of-vehicles","text":"Note All this goes in Vehicles.tsx Import the new Vehicle class import { Vehicle } from './models' ; We maintain state using React hooks. See https://reactjs.org/docs/hooks-overview.html . Hooks are so cool. const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]) We'll be using random placeholders for fields: UUIDs are just the ticket. yarn add uuidv4 @types/uuid And import it import { uuid } from 'uuidv4' ;","title":"Now add some state for the list of vehicles"},{"location":"prepare-ui/#code-to-update-the-list-of-vehicles","text":"A new function, addVehicle() adds a vehicle to the vehicles state. This goes function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } Note The Vehicle class contains metadata that Amplify runtime uses for persistence. This is out-of-bounds for us to update directly. However all persistent classes derived from schema.graphql \u2014including our Vehicle class\u2014includes a constructor with just our fields except id , which is considered part of the metadata. Add a <Button onClick{...}> handler. This also needs to be inside the main function. function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } The event.preventDefault(); is necessary because React decorates native DOM events and we don't want the browser to refresh or reload the window with the underlying event. Add a <Button> and wire up the onclick() handler, and replace the existing <Typography> element with some JSON. import { Typography , Button } from '@material-ui/core' ; return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); Try it out. Nice. Now there's a button \"ADD VEHICLE\" and some JSON for all the vehicles we're adding.","title":"Code to update the list of vehicles"},{"location":"prepare-ui/#the-upshot","text":"We make a very primitive component that updates and displays state. Vehicles.tsx is now import React from 'react' ; import { Typography , Button } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); } export default Vehicles ;","title":"The upshot"},{"location":"releasenotes/","text":"To do \u00b6 Remove redundant indents from all code samples","title":"Release notes"},{"location":"releasenotes/#to-do","text":"Remove redundant indents from all code samples","title":"To do"},{"location":"tools/","text":"This are just the basic recipes. See the stories for all the details. yarn package manager \u00b6 See these instructions https://classic.yarnpkg.com/en/docs/install AWS account and profile \u00b6 zzz xxx The upshot \u00b6 ... TBD","title":"Install the tools"},{"location":"tools/#yarn-package-manager","text":"See these instructions https://classic.yarnpkg.com/en/docs/install","title":"yarn package manager"},{"location":"tools/#aws-account-and-profile","text":"zzz xxx","title":"AWS account and profile"},{"location":"tools/#the-upshot","text":"... TBD","title":"The upshot"}]}